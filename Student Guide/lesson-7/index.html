<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Learning SQL: Aggregate Functions</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN"
      crossorigin="anonymous"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Sono:wght@200;300;400;500;600;700;800&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../styles/style.css" />
    <script src="../scripts/script.js" defer></script>
  </head>

  <body>
    <a href="../">
      <img id="fixed-icon" src="../images/home.svg" alt="Open book" />
    </a>
    <div class="container">
      <h1 class="display-8 text-center mt-5 mb-4">
        Lesson 7 - Aggregate Functions in SQLite
      </h1>
      <div class="card">
        <div class="card-body">
          <h2 class="card-title">Lesson Overview</h2>
<p>
  In this lesson, we'll explore the practical world of analysing sales data using SQL aggregate functions and wildcard searches. We'll be working with the "sales.db" database, which contains a table called "phone_sales" with information about mobile phone sales.
</p>




<ol>
  <li>
    <b>What are Aggregate Functions?</b>  Understanding how these functions help you summarise and analyse data.
  </li>
  <li>
    <b>COUNT, SUM, AVG, MAX, MIN:</b>  Exploring the most commonly used aggregate functions.
  </li>
  <li>
    <b>Wildcards and LIKE:</b>  Searching for patterns in text data.
  </li>
  <li>
    <b>Analysing Sales Data with Python:</b>  Implementing aggregate functions and wildcards in a Python script.
  </li>
</ol>
          <p>
            <img
              class="screenshot"
              src="../images/phone.jpg"
              alt="Phone"
            />
          </p>
          

          <div class="concept-box">
            <h5 class="card-title">
              <img src="../images/bookmark-book.svg" /> Aggregate Functions: Finding Meaning in the Mundane
            </h5>
            <p class="concept">
              Faced with an extensive record of <span class="redacted">sales data</span>, one might feel a sense of detachment from the individual <span class="redacted">transactions</span>, each a mere entry in a vast ledger.  Yet, it is often within these seemingly mundane records that valuable insights lie hidden.  <span class="redacted">Aggregate functions</span> in <span class="redacted">SQL</span> offer a way to unearth these insights, transforming raw data into meaningful summaries.
            </p>
            <p class="concept">
              SQLite provides a variety of aggregate functions to cater to
              different analytical needs. Here are some of the most commonly
              used ones:
            </p>
            <ul>
              <li class="concept">
                <b><code><span class="redacted">COUNT()</span></code></b>: Counts the number of rows that
                match a specified criteria.
              </li>
              <li class="concept">
                <b><code><span class="redacted">SUM()</span></code></b>: Calculates the sum of a numeric
                column.
              </li>
              <li class="concept">
                <b><code><span class="redacted">AVG()</span></code></b>: Determines the average value of a
                numeric column.
              </li>
              <li class="concept">
                <b><code><span class="redacted">MAX()</span></code></b>: Retrieves the maximum value in a
                column.
              </li>
              <li class="concept">
                <b><code><span class="redacted">MIN()</span></code></b>: Retrieves the minimum value in a
                column.
              </li>
            </ul>
            
            
           
          </div>


          <h2 class="card-title">Exploring Aggregate Functions in SQLite</h2>

          <p>
            Let's dive into the "phone_sales" table in the "sales.db" database to
            see these aggregate functions in action.
          </ul>

          <div class="task-box">
            <h5 class="card-title">
              <img src="../images/task-list.svg" /> Task: Explore Aggregate
              Functions in DB Browser
            </h5>

            <p>
              Let's get hands-on with these functions using the
              "sales.db" database.
            </p>
            <ol>
              <li>
                Download the "sales.db" database from the Lesson 7
                resource folder.
              </li>
              <li>
                Open the database in DB Browser and familiarize yourself with
                the "phone_sales" table. It contains information about customer
                purchases, including product IDs, quantities, and prices.
              </li>
              <li>
                In the "Execute SQL" tab, try the following queries:
                <ul>
                  <li>Calculate the total quantity of phones sold.
                    <pre><code>SELECT SUM(count) FROM phone_sales;</code></pre>
                  </li>
                  <li>Find the average price of phones sold.
                    <pre><code>SELECT AVG(count) FROM phone_sales;</code></pre>
                  </li>
                  <li>Determine the highest and lowest prices for phones.
                    <pre><code>SELECT MAX(count), MIN(count) FROM phone_sales;</code></pre>
                  </li>
                  <li>Count the number of sales transactions where the quantity was greater than 5.
                    <pre><code>SELECT COUNT(*) FROM phone_sales WHERE count > 2000;</code></pre>
                  </li>
                  <li>Calculate the total revenue generated from each phone model.
                    <pre><code>SELECT os, SUM(count) FROM phone_sales GROUP BY os;</code></pre>
                  </li>
                </ul>
              </li>
            </ol>
          </div>
          <p>
            Using GROUP BY is an essential part of working with aggregate functions in SQL. It allows you to group rows that have the same values in a specified column, enabling you to perform aggregate calculations on these groups. 
          </p>
          <div class="concept-box">
            <h5 class="card-title">
              <img src="../images/bookmark-book.svg" />  Deconstructing the GROUP BY Query
            </h5>
            <p class="concept">
              This SQL query dives into the sales data to calculate the total sales for each operating system (OS). Let's break down its components:
            </p>
            <ol>
              <li class="concept"><b><code><span class="redacted">os, SUM(count)</span></code></b>: This part specifies that we want to retrieve two pieces of information:
                  <ul>
                      <li class="concept"><code>os</code>: The operating system itself.</li>
                      <li class="concept"><code>SUM(count)</code>: The <span class="redacted">sum</span> of the "<span class="redacted">count</span>" column, which represents the total sales for that specific OS.</li>
                  </ul>
              </li>
              <li class="concept"><b><code><span class="redacted">FROM phone_sales</span></code></b>: This indicates that we're retrieving data from the "phone_sales" table.</li>
              <li class="concept"><b><code><span class="redacted">GROUP BY os</span></code></b>: This is the key to calculating totals for each OS. It groups the rows in the "<span class="redacted">phone_sales</span>" table by the "<span class="redacted">os</span>" column, so that the <code>SUM(count)</code> function calculates the sum for each distinct OS separately.</li>
            </ol>
            <p class="concept">
              In essence, this query provides a breakdown of sales figures by operating system, allowing you to see which OS has the highest or lowest total sales.  It demonstrates the power of combining aggregate functions like SUM with the GROUP BY clause to analyse data at different levels of granularity.
            </p>
          </div>
          <h2 class="card-title">Wildcards and LIKE</h2>
          <p>
            In addition to aggregate functions, SQLite offers the ability to
            search for patterns within text data using wildcards and the
            <code>LIKE</code> operator. This can be useful when you need to
            filter data based on specific criteria.
          </p>
          <div class="task-box">
            <h5 class="card-title task-title">
              <img src="../images/task-list.svg" /> Task: Wildcards and LIKE
            </h5>
            <p>
              Let's explore how to use wildcards and the <code>LIKE</code>
              operator in SQL.
            </p>
            
                Try the following queries in DB Browser:
                <ol>
                  <li>Find all phone operating systems that contain the word "Pro".
                    <pre><code>SELECT * FROM phone_sales WHERE os LIKE '%Pro%';</code></pre>
                  </li>
                  <li>
                    Search for operating systems that contain the word "Android" and have a count greater than 1000 sales.
                    <pre><code>SELECT * FROM phone_sales WHERE os LIKE '%Android%' AND count > 1000;</code></pre>
                  </li>
                  <li>
                    Search for operating systems that start "iOS".
                    <pre><code>SELECT * FROM phone_sales WHERE os LIKE 'iOS%';</code></pre>
                  </li>
                  <li>
                    Search for all sales of non-Android phones and non-Microsoft phones.
                    <pre><code>SELECT * FROM phone_sales WHERE os NOT LIKE '%Android%' AND os NOT LIKE '%Microsoft%';</code></pre>
                  </li>
                </ol>
              
          </div>

          <h5 class="card-title">Combing Aggregate Functions and Wildcards</h5>
          <p>
            Now it is time to combine aggregate functions with wildcards to perform more complex queries. Using the aggregate functions and wildcards together can help you gain deeper insights into your data.
          </p>
          <div class="task-box">
            <h5 class="card-title task-title">
              <img src="../images/task-list.svg" /> Task: Combining Aggregate Functions and Wildcards
            </h5> 
          Make and attempt at the below queries in DB Browser. If you get stuck, try the "Look, Cover, Query, Check" method to help you remember the syntax.
          <ol>
            <li>Calculate the total sales for phones with an OS starting with "Android".
              <pre><code><span class="cover">SELECT SUM(count) FROM phone_sales WHERE os LIKE 'Android%';</span></code></pre>
            </li>
            <li>Find the average sales for phones with an OS containing "iOS".
              <pre><code><span class="cover">SELECT AVG(count) FROM phone_sales WHERE os LIKE '%iOS%';</span></code></pre>
            </li>
            <li>Find the highest and lowest sales figures for phones with an OS not containing "feature".
              <pre><code><span class="cover">SELECT MAX(count), MIN(count) FROM phone_sales WHERE os NOT LIKE '%feature%';</span></code></pre>
            </li>
          </ol>
          </div>

        

          <h2 class="card-title">Combining with Python</h2>
          <p>
            Now, let's integrate these aggregate functions into our Python
            scripts to perform dynamic data analysis.
          </p>

          <div class="task-box">
            <h5 class="card-title">
              <img src="../images/task-list.svg" />Task: Inserting Data Using
              Python
            </h5>
            <p>
              In the lesson resources you will find a Pythong script that prompt the user to input a mobile operating system to then receive the sum of the sales for that OS.
            </p>
            <ol>
              <li>
                Look over the file - make sure to place it in the same folder as
                your students.db database. See if you can work out what code is
                missing.
                <img
                  class="screenshot"
                  src="screenshots/sales.png"
                  alt="Python Script to search sales"
                />
              </li>
              <li>
                If you are really stuck, refer to below for the missing code -
                you can also the final script in the lesson resources.
                <ul>
                  <li>
                    <pre><code><span class="cover">cursor.execute("SELECT SUM(count) FROM phone_sales WHERE os LIKE ?", ('%' + os_search + '%',))</span></code></pre>
                  </li>
                </ul>
              </li>
            </ol>
          </div>
          <p>What's happening here?  Let's break it down:</p>
          <div class="concept-box">
            <h5 class="card-title">
              <img src="../images/bookmark-book.svg" />  Wildcards and Concatenation: A Flexible Search Strategy
            </h5>
            <p class="concept">
              In this Python-SQL <span class="redacted">hybrid</span>, the line <code>('%' + os_search + '%',)</code> showcases the power of combining wildcards and <span class="redacted">concatenation</span> to create flexible search patterns.
            </p>
            <p class="concept">
              The `<span class="redacted">os_search</span>` variable holds the user's input, which represents the operating system they're interested in.  To search for this OS within the "phone_sales" table, we need to construct a pattern that matches any OS containing the user's input, even if it's part of a longer string.
            </p>
            <p class="concept">
              This is where wildcards come in.  The `<span class="redacted">%</span>` symbol is a wildcard that matches any sequence of characters.  By concatenating (<span class="redacted">joining</span>) the `%` symbol with the `os_search` variable and another `%` symbol, we create a <span class="redacted">pattern</span> that matches any string containing the user's input, regardless of what comes before or after it.
            </p>
            <p class="concept">
              For instance, if the user enters "Android", the pattern <code>'%' + os_search + '%'</code> becomes <code>'%Android%'</code>.  This will match any OS that includes the word "Android", such as "Android 4.3", "Android 11", or even "Android 8.0, EMUI 8".
            </p>
          
          </div>

          <h2 class="card-title">Lesson Summary</h2>
          <p>
            In this lesson, we've explored the power of aggregate functions in
            SQLite, enabling us to perform calculations on sets of data and
            extract meaningful insights. We've learned about common aggregate
            functions like <code>COUNT()</code>, <code>SUM()</code>,
            <code>AVG()</code>, <code>MAX()</code>, and
            <code>MIN()</code>, and applied them to real-world scenarios
            using the "sales.db" database. Furthermore, we've
            integrated these functions into Python scripts, showcasing the
            flexibility and dynamism they bring to data analysis.
          </p>
          <p>
            <a href="../lesson-8" class="btn btn-dark-blue">
              Onwards To Lesson 8
            </a>
          </p>
        </div>
      </div>
    </div>
  </body>
</html>